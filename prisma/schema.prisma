// This is your Prisma schema file for Pokemon TCG Deck Builder
// Learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
  previewFeatures = ["fullTextSearch", "postgresqlExtensions"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
  extensions = [pgcrypto]
}

// ==================== ENUMS ====================

enum Supertype {
  POKEMON
  TRAINER
  ENERGY
}

enum Rarity {
  COMMON
  UNCOMMON
  RARE
  RARE_HOLO
  RARE_HOLO_EX
  RARE_HOLO_GX
  RARE_HOLO_V
  RARE_HOLO_VMAX
  RARE_HOLO_VSTAR
  RARE_ULTRA
  RARE_SECRET
  RARE_PRIME
  RARE_ACE
  RARE_BREAK
  LEGEND
  PROMO
  AMAZING_RARE
}

enum CardCondition {
  MINT
  NEAR_MINT
  LIGHTLY_PLAYED
  MODERATELY_PLAYED
  HEAVILY_PLAYED
  DAMAGED
}

enum DeckType {
  CONSTRUCTED
  LIMITED
  PRERELEASE
  THEME
  CUSTOM
}

enum DeckCategory {
  MAIN
  SIDEBOARD
}

enum PriceSource {
  TCGPLAYER
  CARDMARKET
  EBAY
  LOCAL
}

enum PriceType {
  MARKET
  LOW
  MID
  HIGH
  FOIL_LOW
  FOIL_MARKET
  FOIL_HIGH
}

enum Currency {
  USD
  EUR
  GBP
  CAD
  AUD
  JPY
}

enum SubscriptionTier {
  FREE
  BASIC
  PREMIUM
  ULTIMATE
}

// ==================== MODELS ====================

// Sets represent TCG expansions/collections
model Set {
  id                String    @id
  code              String    @unique
  name              String
  series            String
  printedTotal      Int
  total             Int
  releaseDate       DateTime
  updatedAt         DateTime  @updatedAt
  
  // Images
  logoUrl           String?
  symbolUrl         String?
  
  // External API mappings
  ptcgoCode         String?
  tcgplayerGroupId  Int?      @unique
  
  // Legalities
  isLegalStandard   Boolean   @default(false)
  isLegalExpanded   Boolean   @default(false)
  isLegalUnlimited  Boolean   @default(true)
  
  // Relationships
  cards             Card[]
  formats           Format[]  @relation("FormatSets")
  
  // Indexes
  @@index([series])
  @@index([releaseDate])
  @@index([isLegalStandard, isLegalExpanded])
}

// Cards represent individual Pokemon TCG cards
model Card {
  id                      String    @id
  name                    String
  supertype               Supertype
  subtypes                String[]
  level                   String?
  hp                      String?
  types                   String[]
  evolvesFrom             String?
  evolvesTo               String[]  @default([])
  
  // Game mechanics stored as JSON for flexibility
  attacks                 Json?     // Array of {name, cost[], damage, text}
  abilities               Json?     // Array of {name, type, text}
  weaknesses              Json?     // Array of {type, value}
  resistances             Json?     // Array of {type, value}
  rules                   String[]
  
  // Physical attributes
  retreatCost             String[]
  convertedRetreatCost    Int       @default(0)
  
  // Set information
  setId                   String
  set                     Set       @relation(fields: [setId], references: [id])
  number                  String
  printedNumber           String?
  
  // Metadata
  artist                  String?
  rarity                  Rarity?
  flavorText              String?
  nationalPokedexNumbers  Int[]
  regulationMark          String?
  
  // Images
  imageUrlSmall           String
  imageUrlLarge           String
  
  // External IDs for pricing
  tcgplayerId             String?   @unique
  cardmarketId            String?   @unique
  
  // Legalities
  isLegalStandard         Boolean   @default(false)
  isLegalExpanded         Boolean   @default(false)
  isLegalUnlimited        Boolean   @default(true)
  
  // Timestamps
  createdAt               DateTime  @default(now())
  updatedAt               DateTime  @updatedAt
  
  // Relationships
  collections             UserCollection[]
  deckCards               DeckCard[]
  prices                  CardPrice[]
  priceHistory            PriceHistory[]
  favoriteStrategies      Strategy[] @relation("StrategyCards")
  
  // Indexes for search performance
  @@index([name])
  @@index([setId, number])
  @@index([supertype])
  @@index([types])
  @@index([rarity])
  @@index([artist])
  @@index([isLegalStandard, isLegalExpanded])
  @@index([tcgplayerId])
  @@index([cardmarketId])
  
  // Full text search
  @@index([name, flavorText], type: BTree)
}

// Users integrated with Clerk authentication
model User {
  id                String            @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  clerkUserId       String            @unique
  email             String            @unique
  username          String?           @unique
  displayName       String?
  avatarUrl         String?
  bio               String?
  
  // Subscription management
  subscriptionTier  SubscriptionTier  @default(FREE)
  subscriptionEnd   DateTime?
  
  // Preferences stored as JSON
  preferences       Json?             // {theme, language, notifications, etc}
  
  // Feature flags
  features          String[]          @default([])
  
  // Timestamps
  createdAt         DateTime          @default(now())
  updatedAt         DateTime          @updatedAt
  lastActiveAt      DateTime          @default(now())
  
  // Relationships
  collections       UserCollection[]
  decks             Deck[]
  tradeOffers       TradeOffer[]     @relation("OfferedTrades")
  tradeRequests     TradeOffer[]     @relation("RequestedTrades")
  priceAlerts       PriceAlert[]
  
  // Indexes
  @@index([clerkUserId])
  @@index([email])
  @@index([username])
  @@index([subscriptionTier])
}

// User's card collection and wishlist
model UserCollection {
  id              String          @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  userId          String          @db.Uuid
  cardId          String
  quantity        Int             @default(1)
  quantityFoil    Int             @default(0)
  condition       CardCondition   @default(NEAR_MINT)
  language        String          @default("EN")
  purchasePrice   Decimal?        @db.Decimal(10, 2)
  acquiredDate    DateTime?
  notes           String?
  isWishlist      Boolean         @default(false)
  isForTrade      Boolean         @default(false)
  
  // Timestamps
  createdAt       DateTime        @default(now())
  updatedAt       DateTime        @updatedAt
  
  // Relationships
  user            User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  card            Card            @relation(fields: [cardId], references: [id])
  
  // Constraints
  @@unique([userId, cardId, condition, language, isWishlist])
  
  // Indexes
  @@index([userId])
  @@index([cardId])
  @@index([isWishlist])
  @@index([isForTrade])
}

// Deck formats (Standard, Expanded, etc.)
model Format {
  id              String      @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  name            String      @unique
  description     String?
  isActive        Boolean     @default(true)
  rotationDate    DateTime?
  maxDeckSize     Int         @default(60)
  maxCopies       Int         @default(4)
  
  // Relationships
  legalSets       Set[]       @relation("FormatSets")
  decks           Deck[]
  
  // Timestamps
  createdAt       DateTime    @default(now())
  updatedAt       DateTime    @updatedAt
  
  // Indexes
  @@index([isActive])
}

// User's decks
model Deck {
  id              String      @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  userId          String      @db.Uuid
  name            String
  description     String?
  formatId        String?     @db.Uuid
  deckType        DeckType    @default(CONSTRUCTED)
  isPublic        Boolean     @default(false)
  isComplete      Boolean     @default(false)
  tags            String[]    @default([])
  
  // Statistics
  wins            Int         @default(0)
  losses          Int         @default(0)
  draws           Int         @default(0)
  
  // Metadata
  coverCardId     String?
  notes           String?
  
  // Timestamps
  createdAt       DateTime    @default(now())
  updatedAt       DateTime    @updatedAt
  lastPlayedAt    DateTime?
  
  // Relationships
  user            User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  format          Format?     @relation(fields: [formatId], references: [id])
  cards           DeckCard[]
  matchups        Matchup[]   @relation("DeckMatchups")
  opponentIn      Matchup[]   @relation("OpponentMatchups")
  
  // Indexes
  @@index([userId])
  @@index([formatId])
  @@index([isPublic])
  @@index([deckType])
  @@index([tags])
}

// Cards in a deck
model DeckCard {
  id              String        @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  deckId          String        @db.Uuid
  cardId          String
  quantity        Int           @default(1)
  category        DeckCategory  @default(MAIN)
  position        Int?          // For maintaining order
  
  // Timestamps
  addedAt         DateTime      @default(now())
  
  // Relationships
  deck            Deck          @relation(fields: [deckId], references: [id], onDelete: Cascade)
  card            Card          @relation(fields: [cardId], references: [id])
  
  // Constraints
  @@unique([deckId, cardId, category])
  
  // Indexes
  @@index([deckId])
  @@index([cardId])
  @@index([category])
}

// Card pricing data
model CardPrice {
  id              String        @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  cardId          String
  source          PriceSource
  priceType       PriceType
  price           Decimal       @db.Decimal(10, 2)
  currency        Currency      @default(USD)
  url             String?
  
  // Timestamps
  fetchedAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt
  
  // Relationships
  card            Card          @relation(fields: [cardId], references: [id], onDelete: Cascade)
  
  // Constraints
  @@unique([cardId, source, priceType, currency])
  
  // Indexes
  @@index([cardId])
  @@index([source])
  @@index([updatedAt])
}

// Historical price tracking
model PriceHistory {
  id              String        @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  cardId          String
  date            DateTime      @db.Date
  source          PriceSource
  priceType       PriceType
  price           Decimal       @db.Decimal(10, 2)
  currency        Currency      @default(USD)
  volume          Int?          // Trading volume if available
  
  // Relationships
  card            Card          @relation(fields: [cardId], references: [id], onDelete: Cascade)
  
  // Constraints
  @@unique([cardId, date, source, priceType, currency])
  
  // Indexes
  @@index([cardId, date])
  @@index([date])
  @@index([source])
}

// Deck strategies and archetypes
model Strategy {
  id                  String      @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  name                String      @unique
  description         String
  archetype           String
  tier                Int?        // Competitive tier (1-4)
  
  // Strategy details as JSON
  gameplan            Json?       // How to play the deck
  keyCards            Card[]      @relation("StrategyCards")
  counterStrategies   String[]
  weaknesses          String[]
  strengths           String[]
  
  // Metadata
  formatId            String?     @db.Uuid
  popularityScore     Int         @default(0)
  
  // Timestamps
  createdAt           DateTime    @default(now())
  updatedAt           DateTime    @updatedAt
  
  // Indexes
  @@index([archetype])
  @@index([tier])
  @@index([formatId])
}

// Trading system
model TradeOffer {
  id                String        @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  offererId         String        @db.Uuid
  receiverId        String        @db.Uuid
  status            TradeStatus   @default(PENDING)
  
  // Trade details as JSON
  offeredCards      Json          // Array of {cardId, quantity, condition}
  requestedCards    Json          // Array of {cardId, quantity, condition}
  
  message           String?
  counterOfferId    String?       @unique @db.Uuid
  
  // Timestamps
  createdAt         DateTime      @default(now())
  updatedAt         DateTime      @updatedAt
  completedAt       DateTime?
  expiresAt         DateTime?
  
  // Relationships
  offerer           User          @relation("OfferedTrades", fields: [offererId], references: [id])
  receiver          User          @relation("RequestedTrades", fields: [receiverId], references: [id])
  counterOffer      TradeOffer?   @relation("CounterOffer", fields: [counterOfferId], references: [id])
  originalOffer     TradeOffer?   @relation("CounterOffer")
  
  // Indexes
  @@index([offererId])
  @@index([receiverId])
  @@index([status])
  @@index([createdAt])
}

// Price alerts for users
model PriceAlert {
  id              String        @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  userId          String        @db.Uuid
  cardId          String
  targetPrice     Decimal       @db.Decimal(10, 2)
  alertType       AlertType     @default(BELOW)
  priceType       PriceType     @default(MARKET)
  currency        Currency      @default(USD)
  isActive        Boolean       @default(true)
  lastTriggered   DateTime?
  
  // Timestamps
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt
  
  // Relationships
  user            User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  // Indexes
  @@index([userId])
  @@index([cardId])
  @@index([isActive])
}

// Deck matchup tracking
model Matchup {
  id              String        @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  deckId          String        @db.Uuid
  opponentDeckId  String        @db.Uuid
  wins            Int           @default(0)
  losses          Int           @default(0)
  draws           Int           @default(0)
  notes           String?
  
  // Timestamps
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt
  
  // Relationships
  deck            Deck          @relation("DeckMatchups", fields: [deckId], references: [id], onDelete: Cascade)
  opponentDeck    Deck          @relation("OpponentMatchups", fields: [opponentDeckId], references: [id], onDelete: Cascade)
  
  // Constraints
  @@unique([deckId, opponentDeckId])
  
  // Indexes
  @@index([deckId])
  @@index([opponentDeckId])
}

// ==================== ADDITIONAL ENUMS ====================

enum TradeStatus {
  PENDING
  ACCEPTED
  REJECTED
  CANCELLED
  COMPLETED
  EXPIRED
}

enum AlertType {
  ABOVE
  BELOW
}